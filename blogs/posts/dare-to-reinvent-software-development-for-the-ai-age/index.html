<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dare to Reinvent Software Development for the AI age</title>
    <meta name="author" content="Onkar Bhardwaj">
    <meta name="date" content="2025-01-08">
    <meta name="keywords" content="ai">
    <meta name="keywords" content="software">
    
    <!-- KaTeX for LaTeX rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>

    <style>
      
  /* Base content styling */
  .blog-content {
    color: #f4f4f4;
    line-height: 1.6;
    max-width: 800px;
    margin: 0 auto;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
  }

  .ProseMirror {
    color: #f4f4f4;
    line-height: 1.6;
    min-height: 500px;
    padding: 1rem;
    outline: none;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
  }

  /* Paragraphs */
  .blog-content p, .ProseMirror p {
    margin: 1.5em 0;
  }

  /* Headers */
  .blog-content h1, .ProseMirror h1 {
    font-size: 2em;
    color: #f4f4f4;
    margin: 2em 0 1em;
  }

  .blog-content h2, .ProseMirror h2 {
    font-size: 1.5em;
    color: #f4f4f4;
    margin: 2em 0 1em;
    scroll-margin-top: 2rem;
  }

  /* Lists */
  .blog-content ul, .blog-content ol,
  .ProseMirror ul, .ProseMirror ol {
    list-style-type: disc;
    padding-left: 2em;
    margin: 1em 0;
  }

  .blog-content ol, .ProseMirror ol {
    list-style-type: decimal;
  }

  .blog-content li, .ProseMirror li {
    margin: 0;
    line-height: 1.6;
  }

  /* Images */
  .blog-content img, .ProseMirror img {
    display: block;
    max-width: 90%;
    margin: 2em auto;
    height: auto;
  }

  /* Code blocks */
  .blog-content pre, .ProseMirror pre {
    background: #2d2d2d;
    color: #fff;
    padding: 1em;
    border-radius: 4px;
    margin: 1.5em 0;
    white-space: pre-wrap;
    overflow-x: auto;
    font-family: 'Courier New', Courier, monospace;
  }

  .blog-content code, .ProseMirror code {
    background-color: #393939;
    color: #f4f4f4;
    padding: 0.2em 0.4em;
    border-radius: 3px;
    font-family: 'Courier New', Courier, monospace;
  }

  /* Blockquotes */
  .blog-content blockquote, .ProseMirror blockquote {
    border-left: 3px solid #4b5563;
    margin: 1.5em 0;
    padding-left: 1em;
    color: #9ca3af;
  }

  /* Links */
  .blog-content a, .ProseMirror a {
    color: #78a9ff;
    text-decoration: underline;
  }

  /* LaTeX blocks */
  .blog-content [data-type="latex"], .ProseMirror [data-type="latex"] {
    background: #393939;
    padding: 1em;
    margin: 1.5em 0;
    border-radius: 4px;
    text-align: center;
  }

  /* Table of Contents */
  .toc {
    background: #2d2d2d;
    padding: 1.5rem;
    border-radius: 0.5rem;
    margin-bottom: 2rem;
    width: 100%;
    box-sizing: border-box;
  }

  .toc h2 {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.25rem;
    font-weight: 600;
    color: #f4f4f4;
  }

  .toc ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .toc li {
    margin: 0.5rem 0;
  }

  .toc a {
    color: #78a9ff;
    text-decoration: none;
  }

  .toc a:hover {
    text-decoration: underline;
  }

  /* Content containers */
  .content-container, .toc-container {
    padding: 0 1rem;
  }


      
  body {
    margin: 0;
    padding: 0;
    background: #1a1a1a;
  }

  .metadata {
    color: #9ca3af;
    margin-bottom: 2rem;
  }

  .metadata time {
    margin-right: 1rem;
  }

  .tags {
    margin: 1rem 0;
  }

  .tag {
    display: inline-block;
    background: #393939;
    padding: 0.2em 0.6em;
    border-radius: 3px;
    margin-right: 0.5em;
    font-size: 0.9em;
    color: #9ca3af;
  }

    </style>
</head>
<body>
    <article class="blog-content">
        <header>
            <h1>Dare to Reinvent Software Development for the AI age</h1>
            <div class="metadata">
                <time datetime="2025-01-08">1/7/2025</time>
                <span class="author">By Onkar Bhardwaj</span>
            </div>
            
            <div class="tags">
                <span class="tag">ai</span>
                <span class="tag">software</span>
            </div>
            
        </header>
        <div class="content">
            <h2>Prelude</h2><p>These days we hear of many "transformative" tools for software engineering based on LLMs. Although I have tried many (and I am fond of few for sure), here is what I think - we are not daring sufficiently to reinvent! Rather, we are trying to shoehorn the wonderful possibilities into the limitations of the ecosystem of today. I might be a little provocative here but hope some of you will hear me out.</p><p>The history of programming languages and tools is like a story of rising abstractions. From assembly language to high-level programming languages, from procedural to object-oriented programming, each paradigm shift has introduced new layers of abstraction (while preserving access to lower levels when needed). Each advent also brought along its transformative technology and tools. Virtual Machines, Interpreters, IDEs, just to name a few. Viewing from the lens of earlier technologies, new tools/technologies were transformational. Few would have thought of interpreters while writing assembly code.<br><br>Today, supposedly we stand at the door of a revolution, driven by Large Language Models (LLMs). However, the current LLM-powered development tools are more like augmenting our traditional way of working. Code completion, pair programming assistants, AI coding helpers - they all operate within our existing paradigms of files, folders, and repositories. Sure, these tools are powerful, but haven't yet fundamentally changed how we think about software engineering. To me, it feels like early versions of flights operating within the confines of imagination of how birds fly. Are we thinking too small?<br><br>What if we could break free from constraints we've taken for granted?</p><h2>Premise</h2><p>Software is about interfaces, data types, and flows. The codebase establishes various kinds of flows facilitated by interfaces, processing the data defined by data schemas or types. The ideal programming experience is about "what you want to build and how you want to architect it". Hope LLMs and AI age takes us closer to this experience, minimizing the rest.<br><br>(Apologies if someone thinks the above is a gross simplification or plain wrong. I am nowhere an authority on this.)</p><h2>Questioning the Status Quo</h2><p>A typical software engineer has VSCode (or other IDEs) open with synced to a repository containing a bunch of folders and files. They open and edit a bunch of files simultaneously, import interfaces from other modules, write some code, run something in terminal, compile/build it, test it, fix it, etc. Notice that a lot of this is far from our golden goal of "what you want to build and how you want to architect it".</p><p>What if there are no files, folders, imports to deal with [1] - and all you see is your collection if interfaces, data types, and a friendly AI assistant to do your bidding? Let AI agents handle the mechanics of file management and code organization behind the scenes. Imagine describing what you want to build, and having an AI agent handle not just the code generation, but also its optimal placement within the codebase, managing imports, and maintaining consistency.</p><p><img src="./assets/simple-view-light-mode-v1.png" alt="simple-view-light-mode-v1.png"></p>LLMs can generate a ton of code, that's their speciality. What's more important is verifying its correctness, understanding its impact. Now consider an impact analysis tool that, whenever an LLM suggests a code change, automatically visualizes the affected code paths and how they've changed. Instead of manually tracing through function calls and data flow, you could immediately see a clear picture of how your change affects the system. Once a change is approved by the engineer it could be auto-committed by AI agents with appropriate commit messages.</p><p><img src="./assets/impact-analysis-v0.png" alt="impact-analysis-v0.png"></p>Data flow visualization could become more intuitive too. Rather than piecing together how data moves through your system by reading through multiple files, you could ask questions like "Show me how we process user payment information" and get a comprehensive view of the paths. Debugging could get better too. Instead of setting breakpoints and stepping through code, you might have conversations about behavior. "Why did this particular request fail?" might trigger the system to approximately trace the execution path and present you with both the problem and potential solutions (many of us might be using LLMs already for this purpose).</p><p>Documentation could become dynamic, generated on-demand based on your current needs (imagine tutorials generated on-demand focusing on some particular aspect). </p><p>These and other such tools wouldn't require a complete departure from current development practices. Your code would still live in files and repositories, but the LLM agent would handle this organization invisibly. You could still peek behind when needed, but most of your interaction would be at a higher level of abstraction.</p><h2>Beyond</h2><p>The things mentioned above are still in the realm of near-term possibilities. How software engineering would change in the medium-to-long term is impossible to predict (duh!).</p><p>Would we deal with software by expressing intentions, concepts, and intended behaviors? Would we see code expressed entirely different than today, and trust that the actual code on the background should be correct? This is not as radical as it sounds either - we see code in Python/Javascript today, and assume everything behind works correctly down to the machine level. The boundary between design and implementation might blur as we work at a more conceptual level. Perhaps people well-versed in theory can think better how it could look like.</p><h2>Conclusion</h2><p>This is not an article predicting the future. This is merely from the feeling that currently we are imagining the potential of AI confined by our current ways of doing things. A lot of wild things will happen (and if nothing wild happens that itself would be very wild). This is an article meant to be provocative, and if you are not surprised at all then it is because I am not exactly a software guru but an engineer-researcher who enjoys thinking about software. One thing is sure, it is going to be a hell of a ride!</p><p>Happy new year 2025!<br></p><p>Footnotes:<br>[1]<br>It is not too radical an idea though (see <a target="_blank" rel="noopener noreferrer" class="link" href="https://help.eclipse.org/latest/topic/org.eclipse.jdt.doc.user/gettingStarted/images/view_package_explorer_open_type_hierarchy.png">this</a> for Java due to probably how Java works, but probably not many other languages.)</p>
        </div>
    </article>

    <script>
      // Render LaTeX equations
      document.addEventListener('DOMContentLoaded', function() {
        const latexElements = document.querySelectorAll('[data-type="latex"]');
        latexElements.forEach(element => {
          const equation = element.getAttribute('equation');
          if (equation) {
            katex.render(equation, element, {
              throwOnError: false,
              displayMode: true
            });
          }
        });
      });
    </script>
</body>
</html>